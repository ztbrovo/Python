Pre1-1. mod inv
According to Fermat's little theorem, for a prime number  p  and an integer  a  satisfying  0<a<p , the following congruence holds.
ap−1≡1 (mod p) 

Define a function mod_inv(p,a) that is given  p  and  a , and returns the remainder of dividing  ap−2  by  p .
def mod_inv(p,a):
    result = a ** (p-2) % p
    return result
print(mod_inv(13,5) == 8)
print(mod_inv(13,5)*5 % 13 == 1)
print(mod_inv(113,7)*7 % 113 == 1)

Pre1-2. Triangle inequality
There exists a triangle whose positive side lengths are  a ,  b  and  c , if and only if the following equalities hold:
a<b+c  and  b<c+a  and  c<a+b .
Define a function is_triangle(a,b,c) which returns True if the given three positive side lengths a, b, c can form a triangle, and returns False otherwise.
def is_triangle(a, b, c):
    if a < b + c and b < c + a and c < a + b:
      return True
    else:
      return False
print(is_triangle(3,3,3) == True)
print(is_triangle(3,4,5) == True)
print(is_triangle(1,2,3) == False)
print(is_triangle(1,1,2) == False)


Ex1-1. Classifying a triangle.
Define a function triangle(a,b,c), which takes three positive side lengths  a ,  b ,  c  of a triangle as arguments, and returns the following values:

0 if the three side lengths do not satisfy the triangle inequality,
1 if the three side lengths form an acute triangle,
2 if the three side lengths form a right triangle,
3 if the three side lengths form an obtuse triangle.
Complete the definition of classify_triangle(a, b, c) by filling the ... part of the following code cell.
def classify_triangle(a, b, c):
    L = [a, b, c]
    L.sort()
    if L[0] + L[1] <= L[2]:
      return 0
    elif L[0]*L[0] + L[1]*L[1] > L[2]*L[2]:
      return 1
    elif L[0]*L[0] + L[1]*L[1] == L[2]*L[2]:
      return 2
    elif L[0]*L[0] + L[1]*L[1] < L[2]*L[2]:
      return 3
print(classify_triangle(3,6,5) == 3)
print(classify_triangle(3,4,5) == 2)
print(classify_triangle(4,3,3) == 1)
print(classify_triangle(1,1,3) == 0)
print(classify_triangle(1,2,1) == 0)
print(classify_triangle(3,2,1) == 0)

Pre2-1. Extract elements between minimum and maximum
Define a function called between_min_max(distincts). It is given a list distincts whose elements are all distinct. 
It returns the list consisting of those elements of distincts that are surrounded by the minimum and maximum elements of the list. Note that the minimum and maximum elements must be included in the returned list. 
Also note that the maximum element may appear before the minimum element in distincts. (Needless to say, the order of elements in the returned list is as in the original list.)
Complete between_min_max(distincts) by rewriting the ... part in the cell bellow.
def between_min_max(distincts):
    max_index = distincts.index(max(distincts))
    min_index = distincts.index(min(distincts))
    if max_index > min_index:
        return(distincts[min_index:max_index+1])
    else :
        return(distincts[max_index:min_index+1])
print(between_min_max([5,3,1,4,6,2,0]) == [6,2,0])
print(between_min_max([5,3,1,4,6,2]) == [1,4,6])
print(between_min_max([5,3,1,4,2]) == [5,3,1])
print(between_min_max([1]) == [1])

Pre2-2. Increment digits
Define a function inc_digits(s,n), which is given a string s consisting of numerals from 0 to 9 and an integer n, and returns the string consisting of the remainders of dividing the sum of each numeral in s and n by 10.
For example, inc_digits('12', 5) returns the string '67', and inc_digits('457', 5) returns '902' (the remainder of dividing 5+5=10 by 10 is 0, and that of dividing 7+5=12 by 10 is 2.)
For a digit character c, inc(c) returns the corresponding integer. Inversely, for an integer i, str(i) returns the corresponding string.
def inc_digits(s,n):
    result = []
    for digit in s:
        temp = ( int(digit)+n ) % 10
        result.append(str(temp))
    return ''.join(result)
print(inc_digits('12', 5) == '67')
print(inc_digits('457', 5) == '902')


Ex2-1. Calculation of operators
Define a function calculate_ops(lp) that is given a list of tuples lp, such as [('+', 3), ('-', 5), ('+', 2), ('+', 1), ('-', 10)], with each tuple consisting of an operator string (+ or -) and an integer. 
It returns the value obtained by successively applying the operator and the integer in each tuple to the initial value 0.
For example, if lp is as above, calculate_ops(lp) returns the result of calculating 0+3-5+2+1-10.
def calculate_ops(lp):
    v = 0
    for item in lp:
      if item[0] == '+':
        v += item[1]
      elif item[0] == '-':
        v -= item[1]
    return v
print(calculate_ops([('+', 3), ('-', 5), ('+', 2), ('+', 1), ('-', 10)]) == -9)
print(calculate_ops([('-', 1), ('-', 2), ('-', 3)]) == -6)
print(calculate_ops([('+', 1), ('+', 2), ('+', 3)]) == 6)
print(calculate_ops([]) == 0)


Pre3-1. 最初と最後の負数
与えられた数のリストの、最初の負数と最後の負数をタプルにして返す関数 first_last_negative を定義してください。 与えられた数には必ず負数が含まれると仮定して構いません。
def first_last_negative(ln):
    for x in ln:
      if x < 0:
        list_0 = x
        break
    for y in reversed(ln):
      if y < 0:
        list_1 = y
        break
    return (list_0, list_1)
assert first_last_negative([0,1,2,-3,-4,5,6,-7,-8,9,10]) == (-3,-8)
assert first_last_negative([-3]) == (-3,-3)


Pre3-2. 文字列と辞書
文字列 s と 辞書 d が与えられたとき、 s の各文字 c を見ていって、c が d のキーとして登録されていたら、 辞書 d の中のキー c の値を 1 増やす関数 inc_freq(s, d) を定義してください。 （d に新たなキーを登録してはいけません。）
この関数は、引数の辞書の中身を関数内部で更新します。 返り値を返す必要はありません。
def inc_freq(s, d):
  for key in d:
    if s.count(key) > 0:
      d[key] += s.count(key)
  return d
d = {'a':0, 'e':1, 's': 2, '.':3}
inc_freq('Is this a pen?',d)
assert d == {'a':1, 'e':2, 's': 4, '.':3}
inc_freq('Hello.',d)
assert d == {'a':1, 'e':3, 's': 4, '.':4}


Ex3-1. 単語頻度辞書の作成
辞書 dw は、文字列（文書のタイトルを表します）をキー、 文字列（文書を構成する単語を表します）のリストを値とします。 dw を受け取って、単語 �w をキー、dw が持つリスト全体における �w の頻度（すなわち出現回数）を値とする辞書を返す関数 compute_word_frequency(dw) を定義してください。たとえば、 dw が
{'t1': ['I', 'have', 'book'], 't2': ['I', 'student'], 't3': ['I', 'go', 'book', 'store']}であるとき、 compute_word_frequency(dw) は、{'I': 3, 'have': 1, 'book': 2, 'student': 1, 'go': 1, 'store': 1}
を返します。dw が持つリストの長さの総和におおよそ線形で比例する時間で計算してください。
def compute_word_frequency(dw):
    f = {}
    for key in dw:
      for value in dw[key]:
        if value in f:
          f[value] += 1
        else:
          f[value] = 1
    return f
assert compute_word_frequency({'t1': ['I', 'have', 'book'], 't2': ['I', 'student'], 't3': ['I', 'go', 'book', 'store']}) == {'I': 3, 'have': 1, 'book': 2, 'student': 1, 'go': 1, 'store': 1}
assert compute_word_frequency({'k1': ['a', 'b', 'a', 'c'], 'k2': ['b', 'c', 'b', 'd']}) == {'a': 2, 'b': 3, 'c': 2, 'd': 1}


Ex4-1. イテラブルの分割
イテラブル（たとえばリスト）xs とデータ y を受け取って、 xs の要素の並びを y を区切りとして分割し、分割した要素を格納したリストのリストを返す関数 split_iterable(xs,y) を定義してください。 たとえば、
split_iterable([1,2,0,3,4,5,0], 0) は [[1, 2], [3, 4, 5], []] を返します。
split_iterable('/ab/c/def', '/') は、[[], ['a', 'b'], ['c'], ['d', 'e', 'f']] を返します。
split_iterable([], 0) は [[]] を返します。
split_iterable は様々な種類のイテラブルを受け付けますが、 返値は必ずリストのリストになることに注意してください。
ファイルオブジェクトもイテラブルですので、xs がファイルオブジェクトである場合も動作するようにしてください。 たとえば、xs がファイルオブジェクトで、 y が文字列 '\n' であるとき、 xs の中の行は空白行を区切りとして分割され、空でない行のリストのリストが返されます。
def split_iterable(xs,y):
    current_list = []
    result_list = []
    if xs == []:
      result_list.append([])
      return result_list
    for e in xs:
      if e == y:
        result_list.append(current_list)
        current_list = []
      else:
        current_list.append(e)
    result_list.append(current_list)
    return result_list
assert split_iterable([1,2,0,3,4,5,0], 0) == [[1, 2], [3, 4, 5], []]
assert split_iterable([], 0) == [[]]
with open('gokigenyou.txt', 'w', encoding='utf-8') as f:
    f.write('こんにちは。\nごきげんよう。\n\nさようなら。\n')
try:
    with open('gokigenyou.txt', 'r', encoding='utf-8') as f:
        assert split_iterable(f, '\n') == [['こんにちは。\n', 'ごきげんよう。\n'], ['さようなら。\n']]
finally:
    import os, contextlib
    with contextlib.suppress(IOError):
        os.remove('gokigenyou.txt')
        
       
